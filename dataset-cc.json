[
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Fetch data from URL"
      },
      {
        "role": "assistant",
        "content": "GET Request | url,headers,params | data | IMPLICIT | NONE\n({ url, headers, params }, { data }) => {\n    return axios\n      .get(url, { headers, params })\n      .then((res) => data.next(res.data));\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Send HTTP POST requests"
      },
      {
        "role": "assistant",
        "content": "POST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n    const config: AxiosRequestConfig = { headers, params };\n    return axios.post(url, body, config).then((res) => data.next(res.data));\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Update data with PUT request"
      },
      {
        "role": "assistant",
        "content": "PUT Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n    const config: AxiosRequestConfig = { headers, params };\n    return axios.put(url, body, config).then((res) => data.next(res.data));\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "HTTP Request Sender"
      },
      {
        "role": "assistant",
        "content": "Request | url,method,headers,params,data | data | IMPLICIT | NONE\n({ url, method, headers, params, data: body }, { data }) => {\n    const config: AxiosRequestConfig = { method, headers, params };\n    return axios\n      .request({ url, data: body, ...config })\n      .then((res) => data.next(res.data));\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert object to JSON string"
      },
      {
        "role": "assistant",
        "content": "JSON Stringify | object | json | IMPLICIT | NONE\n({ object }, { json }) => json.next(JSON.stringify(object))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Extract object keys"
      },
      {
        "role": "assistant",
        "content": "Keys | object | keys | IMPLICIT | NONE\n({ object }, { keys }) => keys.next(Object.keys(object))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Extract values from object"
      },
      {
        "role": "assistant",
        "content": "Values | object | values | IMPLICIT | NONE\n({ object }, { values }) => values.next(Object.values(object))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Extract object entries"
      },
      {
        "role": "assistant",
        "content": "Entries | object | entries | IMPLICIT | NONE\n({ object }, { entries }) => entries.next(Object.entries(object))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Create object from entries"
      },
      {
        "role": "assistant",
        "content": "From Entries | entries | object | IMPLICIT | NONE\n({ entries }, { object }) => object.next(Object.fromEntries(entries))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Combine objects"
      },
      {
        "role": "assistant",
        "content": "Assign | target,sources | object | IMPLICIT | NONE\n({ target, sources }, { object }) =>\n    object.next(Object.assign(target, ...sources))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Get value from object attribute"
      },
      {
        "role": "assistant",
        "content": "Get Attribute | object,attribute | value | IMPLICIT | NONE\n({ object, attribute }, { value }) =>\n    value.next(attribute.split(\".\").reduce((obj, i) => obj[i], object))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Set object attribute value"
      },
      {
        "role": "assistant",
        "content": "Set Attribute | object,attribute,value | object | IMPLICIT | NONE\n({ object, attribute, value }, { object: outputObject }) => {\n    const attributes = attribute.split(\".\");\n    const last = attributes.pop();\n    const target = attributes.reduce((obj, i) => obj[i], object);\n    target[last] = value;\n    return outputObject.next(object);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Remove object attribute"
      },
      {
        "role": "assistant",
        "content": "Delete Attribute | object,attribute | object | IMPLICIT | NONE\n({ object, attribute }, { object: outputObject }) => {\n    // delete attribute from object while supporting dot notation\n    const attributes = attribute.value.split(\".\");\n    const last = attributes.pop();\n    const target = attributes.reduce((obj, i) => obj[i], object.value);\n    delete target[last];\n    outputObject.next(object.value);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Check if object attribute equals value"
      },
      {
        "role": "assistant",
        "content": "Property Equals | object,attribute,value | true,false | IMPLICIT | NONE\n(inputs, outputs) => {\n    // get attribute from object while supporting dot notation\n    const value = inputs.attribute\n      .split(\".\")\n      .reduce((obj, i) => obj[i], inputs.object);\n    if (value === inputs.value) {\n      outputs.true.next(inputs.object);\n    } else {\n      outputs.false.next(inputs.object);\n    }\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Subtract two numbers"
      },
      {
        "role": "assistant",
        "content": "Subtract | n1,n2 | difference | IMPLICIT | NONE\n({ n1, n2 }, { difference }) => difference.next(n1 - n2)"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Multiply two numbers"
      },
      {
        "role": "assistant",
        "content": "Multiply | n1,n2 | product | IMPLICIT | NONE\n({ n1, n2 }, { product }) => product.next(n1 * n2)"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Divide two numbers"
      },
      {
        "role": "assistant",
        "content": "Divide | n1,n2 | quotient | IMPLICIT | NONE\n({ n1, n2 }, { quotient }) => quotient.next(n1 / n2)"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Calculate remainder of division"
      },
      {
        "role": "assistant",
        "content": "Modulo | n1,n2 | remainder | IMPLICIT | NONE\n({ n1, n2 }, { remainder }) => remainder.next(n1 % n2)"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Calculate power of two numbers"
      },
      {
        "role": "assistant",
        "content": "Power | n1,n2 | power | IMPLICIT | NONE\n({ n1, n2 }, { power }) => power.next(Math.pow(n1, n2))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Calculate square root"
      },
      {
        "role": "assistant",
        "content": "Square Root | n | root | IMPLICIT | NONE\n({ n }, { root }) => root.next(Math.sqrt(n))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Calculate absolute value"
      },
      {
        "role": "assistant",
        "content": "Absolute Value | n | absolute | IMPLICIT | NONE\n({ n }, { absolute }) => absolute.next(Math.abs(n))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Round down number"
      },
      {
        "role": "assistant",
        "content": "Floor | n | floor | IMPLICIT | NONE\n({ n }, { floor }) => floor.next(Math.floor(n))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Round up number"
      },
      {
        "role": "assistant",
        "content": "Ceiling | n | ceiling | IMPLICIT | NONE\n({ n }, { ceiling }) => ceiling.next(Math.ceil(n))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Shorten Number"
      },
      {
        "role": "assistant",
        "content": "Truncate | n | truncated | IMPLICIT | NONE\n({ n }, { truncated }) => truncated.next(Math.trunc(n))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Calculate sine of an angle"
      },
      {
        "role": "assistant",
        "content": "Sin | angle | sine | IMPLICIT | NONE\n({ angle }, { sine }) => sine.next(Math.sin(angle))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Calculate cosine of an angle"
      },
      {
        "role": "assistant",
        "content": "Cos | angle | cosine | IMPLICIT | NONE\n({ angle }, { cosine }) => cosine.next(Math.cos(angle))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Find minimum value"
      },
      {
        "role": "assistant",
        "content": "Min | n1,n2 | min | IMPLICIT | NONE\n({ n1, n2 }, { min }) => min.next(Math.min(n1, n2))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Find maximum of two numbers"
      },
      {
        "role": "assistant",
        "content": "Max | n1,n2 | max | IMPLICIT | NONE\n({ n1, n2 }, { max }) => max.next(Math.max(n1, n2))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert string to integer"
      },
      {
        "role": "assistant",
        "content": "Parse Int | str | int | IMPLICIT | NONE\n({ str }, { int }) => int.next(parseInt(str))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert string to float"
      },
      {
        "role": "assistant",
        "content": "Parse Float | str | float | IMPLICIT | NONE\n({ str }, { float }) => float.next(parseFloat(str))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Round number to fixed decimal places"
      },
      {
        "role": "assistant",
        "content": "To Fixed | number,places | fixed | IMPLICIT | NONE\n({ number, places }, { fixed }) => fixed.next(number.toFixed(places))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert number to exponential notation"
      },
      {
        "role": "assistant",
        "content": "To Exponential | number,places | exponential | IMPLICIT | NONE\n({ number, places }, { exponential }) =>\n    exponential.next(number.toExponential(places))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Compare two numbers"
      },
      {
        "role": "assistant",
        "content": "Greater Than | n1,n2 | result | IMPLICIT | NONE\n({ n1, n2 }, { result }) => result.next(n1 > n2)"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Compare two numbers"
      },
      {
        "role": "assistant",
        "content": "Greater Than Or Equal | n1,n2 | result | IMPLICIT | NONE\n({ n1, n2 }, { result }) => result.next(n1 >= n2)"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Compare two numbers"
      },
      {
        "role": "assistant",
        "content": "Less Than | n1,n2 | result | IMPLICIT | NONE\n({ n1, n2 }, { result }) => result.next(n1 < n2)"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Compare two numbers"
      },
      {
        "role": "assistant",
        "content": "Less Than Or Equal | n1,n2 | result | IMPLICIT | NONE\n({ n1, n2 }, { result }) => result.next(n1 <= n2)"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Calculate sum of list"
      },
      {
        "role": "assistant",
        "content": "Sum List | list | sum | IMPLICIT | NONE\n({ list }, { sum }) => sum.next(list.reduce((a, b) => a + b, 0))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Split a string"
      },
      {
        "role": "assistant",
        "content": "Split | string,separator | value | IMPLICIT | NONE\n({ string, separator }, { value }) =>\n    value.next(string.split(separator))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Join an array with a separator"
      },
      {
        "role": "assistant",
        "content": "Join | array,separator | value | IMPLICIT | NONE\n({ array, separator }, { value }) => value.next(array.join(separator))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Replace text in string"
      },
      {
        "role": "assistant",
        "content": "Replace | string,searchValue,replaceValue | value | IMPLICIT | NONE\n({ string, searchValue, replaceValue }, { value }) =>\n    value.next(string.replace(searchValue, replaceValue))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Remove whitespace from string"
      },
      {
        "role": "assistant",
        "content": "Trim | string | value | IMPLICIT | NONE\n({ string }, { value }) => value.next(string.trim())"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert string to lowercase"
      },
      {
        "role": "assistant",
        "content": "To Lower Case | string | value | IMPLICIT | NONE\n({ string }, { value }) => value.next(string.toLowerCase())"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert string to uppercase"
      },
      {
        "role": "assistant",
        "content": "To Upper Case | string | value | IMPLICIT | NONE\n({ string }, { value }) => value.next(string.toUpperCase())"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Extract a part of a string"
      },
      {
        "role": "assistant",
        "content": "Substring | string,start,end | value | IMPLICIT | NONE\n({ string, start, end }, { value }) =>\n    value.next(string.substring(start, end))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Measure string length"
      },
      {
        "role": "assistant",
        "content": "Length | string | value | IMPLICIT | NONE\n({ string }, { value }) => value.next(string.length)"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Find index of substring"
      },
      {
        "role": "assistant",
        "content": "Index Of | string,searchValue,fromIndex | value | IMPLICIT | NONE\n({ string, searchValue, fromIndex }, { value }) =>\n    value.next(string.indexOf(searchValue, fromIndex))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Get character at index"
      },
      {
        "role": "assistant",
        "content": "Char At | string,index | value | IMPLICIT | NONE\n({ string, index }, { value }) => value.next(string.charAt(index))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert string to kebab case"
      },
      {
        "role": "assistant",
        "content": "To Kebab Case | string | value | IMPLICIT | NONE\n({ string }, { value }) =>\n    value.next(\n      string\n        .replace(/([a-z])([A-Z])/g, \"$1-$2\")\n        .replace(/\\s+/g, \"-\")\n        .toLowerCase()\n    )"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert string to camel case"
      },
      {
        "role": "assistant",
        "content": "To Camel Case | string | value | IMPLICIT | NONE\n({ string }, { value }) =>\n    value.next(\n      string.replace(/(?:^\\w|[A-Z]|\\b\\w|\\s+)/g, (match, index) => {\n        if (+match === 0) return \"\";\n        return index === 0 ? match.toLowerCase() : match.toUpperCase();\n      })\n    )"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert string to Pascal Case"
      },
      {
        "role": "assistant",
        "content": "To Pascal Case | string | value | IMPLICIT | NONE\n({ string }, { value }) =>\n    value.next(\n      string\n        .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (match, index) => {\n          return index === 0 ? match.toUpperCase() : match.toLowerCase();\n        })\n        .replace(/\\s+/g, \"\")\n    )"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert string to snake case"
      },
      {
        "role": "assistant",
        "content": "To Snake Case | string | value | IMPLICIT | NONE\n(string) =>\n    string\n      .replace(/([a-z])([A-Z])/g, \"$1_$2\")\n      .replace(/\\s+/g, \"_\")\n      .toLowerCase()"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Capitalize First Letter of Each Word"
      },
      {
        "role": "assistant",
        "content": "To Title Case | string | value | IMPLICIT | NONE\n({ string }, { value }) =>\n    value.next(\n      string.replace(\n        /\\w\\S*/g,\n        (match) => match.charAt(0).toUpperCase() + match.substr(1).toLowerCase()\n      )\n    )"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Check if string includes value"
      },
      {
        "role": "assistant",
        "content": "Includes | string,searchValue,fromIndex | value | IMPLICIT | NONE\n({ string, searchValue, fromIndex }, { value }) =>\n    value.next(string.includes(searchValue, fromIndex))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Check if string starts with value"
      },
      {
        "role": "assistant",
        "content": "Starts With | string,searchValue,fromIndex | value | IMPLICIT | NONE\n({ string, searchValue, fromIndex }, { value }) =>\n    value.next(string.startsWith(searchValue, fromIndex))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Check if string ends with value"
      },
      {
        "role": "assistant",
        "content": "Ends With | string,searchValue,fromIndex | value | IMPLICIT | NONE\n(string, searchValue, fromIndex) =>\n    string.endsWith(searchValue, fromIndex)"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Check if string is empty"
      },
      {
        "role": "assistant",
        "content": "Is Empty | string | value | IMPLICIT | NONE\n({ string }, { value }) => value.next(string.length === 0)"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Match a string with a regular expression"
      },
      {
        "role": "assistant",
        "content": "Match Regex | string,regex | value | IMPLICIT | NONE\n({ string, regex }, { value }) => value.next(string.match(regex))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Create an empty string"
      },
      {
        "role": "assistant",
        "content": "Empty String |  | string | IMPLICIT | NONE\n({}, { string }) => string.next(\"\")"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Round Robin output distributor"
      },
      {
        "role": "assistant",
        "content": "Round Robin 3 | value | r1,r2,r3 |  | value\nfunction (inputs, outputs, adv) {\n    const { state } = adv;\n    const { r1, r2, r3 } = outputs;\n    const curr = state.get(\"curr\") || 0;\n\n    const o = [r1, r2, r3][curr];\n\n    const nextCurr = (curr + 1) % 3;\n\n    o.next(inputs.item);\n    state.set(\"curr\", nextCurr);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Alternate between two outputs"
      },
      {
        "role": "assistant",
        "content": "Round Robin 2 | value | r1,r2 |  | value\nfunction (inputs, outputs, adv) {\n    const { state } = adv;\n    const { r1, r2 } = outputs;\n    const curr = state.get(\"curr\") || 0;\n\n    const o = [r1, r2][curr];\n\n    const nextCurr = (curr + 1) % 2;\n\n    o.next(inputs.item);\n    state.set(\"curr\", nextCurr);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Round Robin output distributor"
      },
      {
        "role": "assistant",
        "content": "Round Robin 4 | value | r1,r2,r3,r4 |  | value\nfunction (inputs, outputs, adv) {\n    const { state } = adv;\n    const { r1, r2, r3, r4 } = outputs;\n    const curr = state.get(\"curr\") || 0;\n\n    const o = [r1, r2, r3, r4][curr];\n\n    const nextCurr = (curr + 1) % 4;\n\n    o.next(inputs.item);\n    state.set(\"curr\", nextCurr);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Publish a value to a channel"
      },
      {
        "role": "assistant",
        "content": "Publish | key,value |  | IMPLICIT | NONE\nfunction (inputs, _, adv) {\n    // magic here\n    const nsKey = `${adv.ancestorsInsIds}__${inputs.key}`;\n\n    PubSub.publish(nsKey, inputs.value);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Subscribe to a PubSub channel"
      },
      {
        "role": "assistant",
        "content": "Subscribe | key,initial | value |  | NONE\nfunction (inputs, outputs, adv) {\n    const { value } = outputs;\n    const nsKey = `${adv.ancestorsInsIds}__${inputs.key}`;\n    const token = PubSub.subscribe(nsKey, (_, data) => {\n      value.next(data);\n    });\n\n    if (typeof inputs.initial !== \"undefined\") {\n      value.next(inputs.initial);\n    }\n\n    adv.onCleanup(() => {\n      PubSub.unsubscribe(token);\n    });\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Split boolean values"
      },
      {
        "role": "assistant",
        "content": "Boolean Split | value,trueValue,falseValue | true,false | IMPLICIT | NONE\nfunction (inputs, outputs) {\n    const { true: trueOutput, false: falseOutput } = outputs;\n    const { value, trueValue, falseValue } = inputs;\n    if (value) {\n      trueOutput.next(trueValue ?? true);\n    } else {\n      falseOutput.next(falseValue ?? false);\n    }\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Trigger-based emitter"
      },
      {
        "role": "assistant",
        "content": "Emit on Trigger | value,trigger | result | IMPLICIT | NONE\nfunction (inputs, outputs) {\n    const { result } = outputs;\n    const { value, trigger } = inputs;\n    if (trigger !== undefined) {\n      result.next(value);\n    }\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "A part that routes values to different outputs"
      },
      {
        "role": "assistant",
        "content": "Switch 3 | value,firstCase,secondCase,thirdCase,outputValue | first,second,third,default | IMPLICIT | NONE\nfunction (inputs, outputs) {\n    const {\n      first,\n      second,\n      third,\n      default: defaultOutput,\n      outputValue,\n    } = outputs;\n    const { value, firstCase, secondCase, thirdCase } = inputs;\n    if (value === firstCase) {\n      first.next(outputValue ?? value);\n    } else if (value === secondCase) {\n      second.next(outputValue ?? value);\n    } else if (value === thirdCase) {\n      third.next(outputValue ?? value);\n    } else {\n      defaultOutput.next(outputValue ?? value);\n    }\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "A part that switches between two cases"
      },
      {
        "role": "assistant",
        "content": "Switch 2 | value,firstCase,secondCase,outputValue | first,second,default | IMPLICIT | NONE\nfunction (inputs, outputs) {\n    const { first, second, default: defaultOutput, outputValue } = outputs;\n    const { value, firstCase, secondCase } = inputs;\n    if (value === firstCase) {\n      first.next(outputValue ?? value);\n    } else if (value === secondCase) {\n      second.next(outputValue ?? value);\n    } else {\n      defaultOutput.next(outputValue ?? value);\n    }\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Delay values"
      },
      {
        "role": "assistant",
        "content": "Delay | value,delay | delayedValue | IMPLICIT | NONE\nasync ({ value, delay }, { delayedValue }) => {\n    await new Promise((resolve) => setTimeout(resolve, delay));\n    delayedValue.next(value);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "A part that emits a value at a fixed interval"
      },
      {
        "role": "assistant",
        "content": "Interval | value,interval | value |  | value,interval\n(inputs, outputs, adv) => {\n    if (adv.state.get(\"timer\")) {\n      clearInterval(adv.state.get(\"timer\"));\n    }\n\n    const timer = setInterval(() => {\n      outputs.value.next(inputs.value);\n    }, inputs.interval);\n\n    adv.state.set(\"timer\", timer);\n\n    adv.onCleanup(() => {\n      clearInterval(timer);\n    });\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Throttle incoming values"
      },
      {
        "role": "assistant",
        "content": "Debounce | value,wait | result | result | value\nfunction (inputs, outputs, adv) {\n    const { value, wait } = inputs;\n    const { result } = outputs;\n\n    const timer = adv.state.get(\"timer\");\n    if (timer) {\n      clearTimeout(timer);\n    }\n\n    const newTimer = setTimeout(() => {\n      result.next(value);\n    }, wait);\n\n    adv.state.set(\"timer\", newTimer);\n\n    adv.onCleanup(() => {\n      clearTimeout(timer);\n    });\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Limit input frequency"
      },
      {
        "role": "assistant",
        "content": "Throttle | value,wait | result | result | value\nfunction (inputs, outputs, adv) {\n    const { value, wait } = inputs;\n    const { result } = outputs;\n\n    const timer = adv.state.get(\"timer\");\n    if (timer) {\n      adv.onError(new ThrottleError(value));\n      return;\n    } else {\n      result.next(value);\n      const newTimer = setTimeout(() => {\n        adv.state.set(\"timer\", null);\n      }, wait);\n      adv.state.set(\"timer\", newTimer);\n    }\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Compare two values"
      },
      {
        "role": "assistant",
        "content": "Equals (Bool) | a,b | result | IMPLICIT | NONE\n({ a, b }, { result }) => result.next(a === b)"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Compare two values"
      },
      {
        "role": "assistant",
        "content": "Equals | a,b | true,false | IMPLICIT | NONE\n(inputs, outputs) => {\n    const { a, b } = inputs;\n    const { true: trueOutput, false: falseOutput } = outputs;\n\n    if (a === b) {\n      trueOutput.next(a);\n    } else {\n      falseOutput.next(a);\n    }\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Check if list is empty"
      },
      {
        "role": "assistant",
        "content": "List Is Empty | list | isEmpty | IMPLICIT | NONE\n({ list }, { isEmpty }) => isEmpty.next(list.length === 0)"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Get element from list"
      },
      {
        "role": "assistant",
        "content": "Get List Element | list,index | element | IMPLICIT | NONE\n({ list, index }, { element }) => element.next(list[index])"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Repeat a value multiple times"
      },
      {
        "role": "assistant",
        "content": "Repeat | value,times | list | IMPLICIT | NONE\n({ value, times }, { list }) => {\n    const result = [];\n    for (let i = 0; i < times; i++) {\n      result.push(value);\n    }\n    return list.next(result);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Create a list from two values"
      },
      {
        "role": "assistant",
        "content": "List From 2 | value1,value2 | list | IMPLICIT | NONE\n({ value1, value2 }, { list }) => list.next([value1, value2])"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Create a list from 3 values"
      },
      {
        "role": "assistant",
        "content": "List From 3 | value1,value2,value3 | list | IMPLICIT | NONE\n({ value1, value2, value3 }, { list }) =>\n    list.next([value1, value2, value3])"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Create a list from values"
      },
      {
        "role": "assistant",
        "content": "List From 4 | value1,value2,value3,value4 | list | IMPLICIT | NONE\n({ value1, value2, value3, value4 }, { list }) =>\n    list.next([value1, value2, value3, value4])"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Create a list from 5 values"
      },
      {
        "role": "assistant",
        "content": "List From 5 | value1,value2,value3,value4,value5 | list | IMPLICIT | NONE\n({ value1, value2, value3, value4, value5 }, { list }) =>\n    list.next([value1, value2, value3, value4, value5])"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Combine two lists"
      },
      {
        "role": "assistant",
        "content": "Concat Lists | list1,list2 | list | IMPLICIT | NONE\n({ list1, list2 }, { list }) => list.next([...list1, ...list2])"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Reverse a list"
      },
      {
        "role": "assistant",
        "content": "Reverse | list | reversed | IMPLICIT | NONE\n({ list }, { reversed }) => reversed.next(list.reverse())"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Split list into head and rest"
      },
      {
        "role": "assistant",
        "content": "Head and rest | list | head,rest | IMPLICIT | NONE\n(inputs, outputs) => {\n    const { list } = inputs;\n    const { head, rest } = outputs;\n    head.next(list[0]);\n    rest.next(list.slice(1));\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Split a pair into two items"
      },
      {
        "role": "assistant",
        "content": "Split Pair | pair | item1,item2 | IMPLICIT | NONE\n(inputs, outputs) => {\n    const { pair } = inputs;\n    const { item1, item2 } = outputs;\n    item1.next(pair[0]);\n    item2.next(pair[1]);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Split a list into three items"
      },
      {
        "role": "assistant",
        "content": "Split Triple | triple | item1,item2,item3 | IMPLICIT | NONE\n(inputs, outputs) => {\n    const { list } = inputs;\n    const { item1, item2, item3 } = outputs;\n    item1.next(list[0]);\n    item2.next(list[1]);\n    item3.next(list[2]);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Split a list into four items"
      },
      {
        "role": "assistant",
        "content": "Split Quadruple | quadruple | item1,item2,item3,item4 | IMPLICIT | NONE\n(inputs, outputs) => {\n    const { list } = inputs;\n    const { item1, item2, item3, item4 } = outputs;\n    item1.next(list[0]);\n    item2.next(list[1]);\n    item3.next(list[2]);\n    item4.next(list[3]);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Accumulate values until trigger"
      },
      {
        "role": "assistant",
        "content": "Accumulate Values by Trigger | value,reset | accumulated | IMPLICIT | value,reset\n(inputs, outputs, adv) => {\n    const { item, until } = inputs;\n    const { r } = outputs;\n    const { state } = adv;\n\n    let list = state.get(\"list\") || [];\n\n    if (typeof item !== \"undefined\") {\n      list.push(item);\n      state.set(\"list\", list);\n    }\n\n    if (typeof until !== \"undefined\") {\n      r.next(list);\n    }\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Accumulate values over time"
      },
      {
        "role": "assistant",
        "content": "Accumulate Values by Time | value,time | accumulated | IMPLICIT | value\n(inputs, outputs, adv) => {\n    const { value, time } = inputs;\n    const { accumulated } = outputs;\n    const { state } = adv;\n\n    let list = state.get(\"list\") || [];\n\n    const bob = Date.now() % 1000;\n    console.log(\"called\", inputs.value, inputs.time, bob);\n    state.set(\"bob\", 2);\n    console.log(Array.from(state.entries()));\n\n    if (typeof value !== \"undefined\") {\n      list.push(value);\n      state.set(\"list\", list);\n    }\n\n    if (state.get(\"timeout\")) {\n      clearTimeout(state.get(\"timeout\"));\n    }\n\n    const promise = new Promise<void>((resolve) => {\n      state.set(\"resolve\", resolve);\n    });\n\n    state.set(\n      \"timeout\",\n      setTimeout(() => {\n        console.log(\"emitting\", list, bob, Date.now() % 1000);\n        accumulated.next(list);\n\n        state.set(\"list\", []);\n        const resolve = state.get(\"resolve\");\n        if (!resolve) {\n          throw new Error(\"resolve is undefined\");\n        }\n        resolve();\n      }, time)\n    );\n\n    return promise;\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Count Values"
      },
      {
        "role": "assistant",
        "content": "Accumulate Values by Count | value,count | accumulated | accumulated | value\n(inputs, outputs, adv) => {\n    const { value, count } = inputs;\n    const { accumulated } = outputs;\n    const { state } = adv;\n\n    let list = state.get(\"list\") || [];\n\n    if (typeof value !== \"undefined\") {\n      list.push(value);\n      state.set(\"list\", list);\n    }\n\n    if (list.length >= count) {\n      accumulated.next(list);\n    }\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Accumulate values by count"
      },
      {
        "role": "assistant",
        "content": "Accumulate Some Values by Count | accept,ignore,count | accumulated,ignored | IMPLICIT | accept,ignore\n(inputs, outputs, adv) => {\n    const { accept, ignore, count } = inputs;\n    const { accumulated, ignored } = outputs;\n    const { state } = adv;\n\n    let list = state.get(\"list\") || [];\n    let ignoredList = state.get(\"ignored\") || [];\n\n    if (typeof accept !== \"undefined\") {\n      list.push(accept);\n      state.set(\"list\", list);\n    }\n\n    if (typeof ignore !== \"undefined\") {\n      ignoredList.push(ignore);\n      state.set(\"ignored\", ignored);\n    }\n\n    if (list.length + ignoredList.length >= count) {\n      accumulated.next(list);\n      ignored.next(ignored);\n    }\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Add item to list"
      },
      {
        "role": "assistant",
        "content": "Append | list,item | list | IMPLICIT | NONE\n({ list, item }, { list: outputList }) => {\n    outputList.next([...list, item]);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Remove item from list"
      },
      {
        "role": "assistant",
        "content": "Remove | list,item | list | IMPLICIT | NONE\n({ list, item }, { list: outputList }) => {\n    outputList.next(list.filter((i) => i !== item));\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Remove an item from a list"
      },
      {
        "role": "assistant",
        "content": "Remove At | list,index | list | IMPLICIT | NONE\n({ list, index }, { list: outputList }) => {\n    outputList.next(list.filter((_, idx) => idx !== index));\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Extract a portion of a list"
      },
      {
        "role": "assistant",
        "content": "Slice | list,start,end | list | IMPLICIT | NONE\n({ list, start, end }, { list: outputList }) => {\n    outputList.next(list.slice(start, end));\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Flatten a list of lists"
      },
      {
        "role": "assistant",
        "content": "Flatten | list | list | IMPLICIT | NONE\n({ list }, { list: outputList }) => {\n    outputList.next(list.reduce((acc, item) => [...acc, ...item], []));\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Log a value"
      },
      {
        "role": "assistant",
        "content": "Log | value |  | IMPLICIT | NONE\n({ value }) => console.log(value)"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Part that logs errors"
      },
      {
        "role": "assistant",
        "content": "Error | value |  | IMPLICIT | NONE\n({ value }) => console.error(value)"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Current date and time"
      },
      {
        "role": "assistant",
        "content": "Now String |  | now | IMPLICIT | NONE\n(_, { now }) => now.next(new Date().toString())"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Current time as ISO string"
      },
      {
        "role": "assistant",
        "content": "Now ISO String |  | now | IMPLICIT | NONE\n(_, { now }) => now.next(new Date().toISOString())"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Current Unix Time"
      },
      {
        "role": "assistant",
        "content": "Now Unix Time |  | now | IMPLICIT | NONE\n(_, { now }) => now.next(new Date().getTime())"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert Unix Time to Date"
      },
      {
        "role": "assistant",
        "content": "Date From Unix Time | time | date | IMPLICIT | NONE\n({ time }, { date }) => date.next(new Date(time))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert string to date"
      },
      {
        "role": "assistant",
        "content": "Date From String | string | date | IMPLICIT | NONE\n({ string }, { date }) => date.next(new Date(string))"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert ISO string to date"
      },
      {
        "role": "assistant",
        "content": "Date From ISO String | string | date | IMPLICIT | NONE\nasync ({ string }, { date }, { onError }) => {\n    try {\n      date.next(new Date(string));\n    } catch (e) {\n      console.error(\"Error in part\", e);\n      onError(e);\n    }\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert date to string"
      },
      {
        "role": "assistant",
        "content": "Date To String | date | string | IMPLICIT | NONE\n({ date }, { string }) => string.next(date.toString())"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert date to ISO string"
      },
      {
        "role": "assistant",
        "content": "Date To ISO String | date | string | IMPLICIT | NONE\n({ date }, { string }) => string.next(date.toISOString())"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert date to Unix time"
      },
      {
        "role": "assistant",
        "content": "Date To Unix Time | date | time | IMPLICIT | NONE\n({ date }, { time }) => time.next(date.getTime())"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Calculate current month"
      },
      {
        "role": "assistant",
        "content": "Month To Date | date | month | IMPLICIT | NONE\n({ date }, { month }) => month.next(date.getMonth())"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert date to day"
      },
      {
        "role": "assistant",
        "content": "Date To Day | date | day | IMPLICIT | NONE\n({ date }, { day }) => day.next(date.getDate())"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert date to hours"
      },
      {
        "role": "assistant",
        "content": "Date To Hours | date | hours | IMPLICIT | NONE\n({ date }, { hours }) => hours.next(date.getHours())"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert date to minutes"
      },
      {
        "role": "assistant",
        "content": "Date To Minutes | date | minutes | IMPLICIT | NONE\n({ date }, { minutes }) => minutes.next(date.getMinutes())"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert date to seconds"
      },
      {
        "role": "assistant",
        "content": "Date To Seconds | date | seconds | IMPLICIT | NONE\n({ date }, { seconds }) => seconds.next(date.getSeconds())"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert date to milliseconds"
      },
      {
        "role": "assistant",
        "content": "Date To Milliseconds | date | milliseconds | IMPLICIT | NONE\n({ date }, { milliseconds }) =>\n    milliseconds.next(date.getMilliseconds())"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Convert date to day of week"
      },
      {
        "role": "assistant",
        "content": "Date To Day Of Week | date | day | IMPLICIT | NONE\n({ date }, { day }) => day.next(date.getDay())"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Get Timezone Offset from Date"
      },
      {
        "role": "assistant",
        "content": "Date To Timezone Offset | date | offset | IMPLICIT | NONE\n({ date }, { offset }) => offset.next(date.getTimezoneOffset())"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Set a global state value"
      },
      {
        "role": "assistant",
        "content": "Set Global State | key,value | setValue | IMPLICIT | NONE\n({ key, value }, { setValue }, { globalState }) => {\n    globalState.set(key, value);\n    setValue.next(value);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Retrieve value from global state"
      },
      {
        "role": "assistant",
        "content": "Get Global State | key,defaultValue | value | IMPLICIT | NONE\n({ key, defaultValue }, { value }, { globalState, onError }) => {\n    const val = globalState.get(key);\n    if (val === undefined && defaultValue === undefined) {\n      onError(new Error(`Key ${key} is not set`));\n    } else {\n      value.next(globalState.get(key) ?? defaultValue);\n    }\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Connect to database"
      },
      {
        "role": "assistant",
        "content": "Connect | host,port,database,user,password | connection | IMPLICIT | NONE\nasync ({ path }, {}) => {\n    await fs.promises.unlink(path);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Find a single document in a MongoDB collection"
      },
      {
        "role": "assistant",
        "content": "FindOne | connection,collection,query,options | result | IMPLICIT | NONE\nasync ({ connection, collection, query, options }, { result }) => {\n    const res = await connection\n      .db()\n      .collection(collection)\n      .find(query, options)\n      .toArray();\n    result.next(res);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Check if file exists"
      },
      {
        "role": "assistant",
        "content": "Disconnect | connection |  | IMPLICIT | NONE\nasync ({ path }, { exists }) => {\n    // check if file in path exists\n    return exists.next(await fs.promises.access(path, fs.constants.F_OK));\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Insert a document into a collection"
      },
      {
        "role": "assistant",
        "content": "InsertOne | connection,collection,document,options | result | IMPLICIT | NONE\nasync ({ connection }) => {\n    await connection.close();\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Insert multiple documents to a collection"
      },
      {
        "role": "assistant",
        "content": "InsertMany | connection,collection,documents,options | result | IMPLICIT | NONE\nasync ({ connection }) => {\n    await connection.value?.end();\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Update a single document in a MongoDB collection"
      },
      {
        "role": "assistant",
        "content": "UpdateOne | connection,collection,filter,update,options | result | IMPLICIT | NONE\nasync ({ connection, collection, document, options }, { result }) => {\n    const res = await connection\n      .db()\n      .collection(collection)\n      .insertOne(document, options);\n    result.next(res);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Update multiple documents in a collection"
      },
      {
        "role": "assistant",
        "content": "UpdateMany | connection,collection,filter,update,options | result | IMPLICIT | NONE\nasync ({ connection, collection, documents, options }, { result }) => {\n    const res = await connection\n      .db()\n      .collection(collection)\n      .insertMany(documents, options);\n    result.next(res);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Delete a document from a MongoDB collection"
      },
      {
        "role": "assistant",
        "content": "DeleteOne | connection,collection,filter,options | result | IMPLICIT | NONE\nasync (\n    { connection, collection, filter, update, options },\n    { result }\n  ) => {\n    const res = await connection\n      .db()\n      .collection(collection)\n      .updateOne(filter, update, options);\n    result.next(res);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Delete multiple documents from a MongoDB collection"
      },
      {
        "role": "assistant",
        "content": "DeleteMany | connection,collection,filter,options | result | IMPLICIT | NONE\nasync (\n    { connection, collection, filter, update, options },\n    { result }\n  ) => {\n    const res = await connection\n      .db()\n      .collection(collection)\n      .updateMany(filter, update, options);\n    result.next(res);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Count documents in MongoDB collection"
      },
      {
        "role": "assistant",
        "content": "CountDocuments | connection,collection,query,options | result | IMPLICIT | NONE\nasync ({ connection, collection, filter, options }, { result }) => {\n    const res = await connection\n      .db()\n      .collection(collection)\n      .deleteOne(filter, options);\n    result.next(res);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Create Index"
      },
      {
        "role": "assistant",
        "content": "CreateIndex | connection,collection,fieldOrSpec,options | result | IMPLICIT | NONE\nasync ({ connection, collection, filter, options }, { result }) => {\n    const res = await connection\n      .db()\n      .collection(collection)\n      .deleteMany(filter, options);\n    result.next(res);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Create Indexes"
      },
      {
        "role": "assistant",
        "content": "CreateIndexes | connection,collection,indexes,options | result | IMPLICIT | NONE\nasync ({ connection, collection, query, options }, { result }) => {\n    const res = await connection\n      .db()\n      .collection(collection)\n      .countDocuments(query, options);\n    result.next(res);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Write contents to file"
      },
      {
        "role": "assistant",
        "content": "Write File | path,contents,encoding |  | IMPLICIT | NONE\nasync ({ connection, collection, indexes, options }, { result }) => {\n    const res = await connection\n      .db()\n      .collection(collection)\n      .createIndexes(indexes, options);\n    result.next(res);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Append to file"
      },
      {
        "role": "assistant",
        "content": "Append File | path,contents,encoding |  | IMPLICIT | NONE\nasync ({ path, encoding }, { contents }) => {\n    return contents.next(await fs.promises.readFile(path, encoding));\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Delete a file"
      },
      {
        "role": "assistant",
        "content": "Delete File | path |  | IMPLICIT | NONE\n({ path, contents, encoding }) => {\n    return fs.promises.writeFile(path, contents, encoding);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Check if file exists"
      },
      {
        "role": "assistant",
        "content": "Exists | path | exists | IMPLICIT | NONE\n({ path, contents, encoding }) => {\n    return fs.promises.appendFile(path, contents, encoding);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Connect to database"
      },
      {
        "role": "assistant",
        "content": "Connect | host,port,database,user,password | connection | IMPLICIT | NONE\nasync ({ path }, {}) => {\n    await fs.promises.unlink(path);\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Check if file exists"
      },
      {
        "role": "assistant",
        "content": "Disconnect | connection |  | IMPLICIT | NONE\nasync ({ path }, { exists }) => {\n    // check if file in path exists\n    return exists.next(await fs.promises.access(path, fs.constants.F_OK));\n  }"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Your job is to receive user prompts and generate a Flyde part based on the prompt. Do not add explanations. Flyde is a flow-based programming tool that uses TypeScript to declare nodes.\nEach node as an id, 0 or more inputs, 0 or more outputs, and a function that is called when the node is executed.\nThe function receives the inputs and returns the outputs. The function can be synchronous or asynchronous. The function has access to the input values, and output objects (RxJS Subjects) and can trigger any output by calling `outputs.outputName.next(value)`. The function may return a cleanup function.\nThe function haa the following signature: (inputs: Record<string, any>, outputs: Record<string, Output>, advanced: AdvancedContext) => void | Promise<void> | () => void | Promise<() => void>.\nThe advanced context has the following properties: \"state\", \"globalState\", \"onCleanup\", \"onError\" and a \"externalContext\".  state is a key-value store that is persisted between executions. globalState is a key-value store that is persisted between executions and is shared between all flows. onError is a function that can be called with an error to trigger the error output. externalContext contains data passed by the user to the flow's execution.\nFlyde parts can be in one of 2 states: \"pending values\" or \"processing\". A part starts processing once it has all required inputs. \nParts can have implicit completion or explicit completion. Implicit completion means that the part will complete once the function has returned a value. If the value is a promise, it'll wait for the promise to be resolved.\nExplicit completion means that the user defines 1 or more outputs that once a value is emitted from them, they will trigger the completion of the part.\nOnce a part is processing, new inputs will be queued and processed only when it is done. In order for a part to receive new inputs while it is processing, the inputs need to be marked as \"reactive inputs\".\nFor example, a debounce node will receive a value and emit it after a delay. If it receives a new value before the delay is over, it will cancel the previous delay and start a new one. In order to do that, it needs to receive the new value while it is processing. Therefore, it needs to mark the input as \"reactive input\".\n\nFlyde parts start with a metadata line that defines the part's ID, inputs, outputs, completion type and reactive inputs, followed by the function declaration.\nThe metadata looks like this:\nID | Inputs separated by a comma (or \"None\" for 0) | Outputs separated by a comma (or \"None\" for 0) | Completion type: IMPLICIT or the name of the output that triggers the completion | Reactive inputs separated by a comma (or \"NONE\" for 0)\n\nHere are some examples, separated by \"-----\":\nDebounce | value,wait | result | result | value\nfunction ({value, wait}, {result}, {state, onCleanup}) {\n  const timer = state.get(\"timer\");\n  if (timer) {\n    clearTimeout(timer);\n  }\n  const newTimer = setTimeout(() => {\n    result.next(value);\n  }, wait);\n\n  state.set(\"timer\", newTimer);\n  onCleanup(() => clearTimeout(timer));\n}\n-----\nAdd | n1,n2 | sum | IMPLICIT | NONE\nfunction ({n1, n2}, {sum}) {\n  sum.next(n1 + n2);\n}\n-----\nPOST Request | url,headers,params,data | data | IMPLICIT | NONE\n({ url, headers, params, data: body }, { data }) => {\n  const config: AxiosRequestConfig = { headers, params };\n  return axios.post(url, body, config).then((res) => data.next(res.data));\n} \n-----\nSplit Pair | pair | item1,item2 | IMPLICIT | NONE\n({pair}, {item1, item2}) => {\n  item1.next(pair[0]);\n  item2.next(pair[1]);\n}\n-----\nMerge Pair | item1,item2 | pair | IMPLICIT | NONE\n({item1, item2}, {pair}) => {\n  pair.next([item1, item2]);\n}\n-----\nLimit Times | item,times,reset | ok | item,reset\nfunction ({item, times, reset}, {ok}, {onError}) {\n  if (typeof reset !== \"undefined\") {\n    state.set(\"val\", 0);\n    return;\n  }\n\n  const curr = (state.get(\"val\") || 0) + 1;\n  state.set(\"val\", curr);\n  if (curr >= times) {\n    adv.onError(new Error(`Limit of ${times} reached`));\n  } else {\n    ok.next(item);\n  }\n}\n\nYour job is to receive a prompt from the user describing a node, and generate the metadata and function declaration for that node, and nothing more.\n\n"
      },
      {
        "role": "user",
        "content": "Run SQL query"
      },
      {
        "role": "assistant",
        "content": "Query | connection,query | result | IMPLICIT | NONE\nasync ({ connection, query }, { result }) => {\n    const queryResult = await connection.value?.query(query);\n    result.next(queryResult?.rows);\n  }"
      }
    ]
  },
  {
    "prompt": "Parse JSON string to object\n\n###\n\n",
    "completion": " J###"
  },
  {
    "prompt": "Convert JSON string to object\n\n###\n\n",
    "completion": " S###"
  },
  {
    "prompt": "JSON string to object converter\n\n###\n\n",
    "completion": " J###"
  },
  {
    "prompt": "JSON string parser\n\n###\n\n",
    "completion": " S###"
  },
  {
    "prompt": "Add two numbers\n\n###\n\n",
    "completion": " A###"
  },
  {
    "prompt": "Calculate sum of two numbers\n\n###\n\n",
    "completion": " d###"
  },
  {
    "prompt": "Simple addition\n\n###\n\n",
    "completion": " A###"
  },
  {
    "prompt": "Addition of two numbers\n\n###\n\n",
    "completion": " d###"
  },
  {
    "prompt": "Round a number\n\n###\n\n",
    "completion": " R###"
  },
  {
    "prompt": "Create a rounded number\n\n###\n\n",
    "completion": " o###"
  },
  {
    "prompt": "Round to precision\n\n###\n\n",
    "completion": " T###"
  },
  {
    "prompt": "Set number precision\n\n###\n\n",
    "completion": " o###"
  },
  {
    "prompt": "Precision calculator\n\n###\n\n",
    "completion": " T###"
  },
  {
    "prompt": "Number precision\n\n###\n\n",
    "completion": " o###"
  },
  {
    "prompt": "Combine two values\n\n###\n\n",
    "completion": " C###"
  },
  {
    "prompt": "Concatenate two inputs\n\n###\n\n",
    "completion": " o###"
  },
  {
    "prompt": "Join two values together\n\n###\n\n",
    "completion": " C###"
  },
  {
    "prompt": "Create a single value from two inputs\n\n###\n\n",
    "completion": " o###"
  },
  {
    "prompt": "Find last occurrence of substring\n\n###\n\n",
    "completion": " L###"
  },
  {
    "prompt": "Get index of last substring\n\n###\n\n",
    "completion": " a###"
  },
  {
    "prompt": "Find last index of substring in string\n\n###\n\n",
    "completion": " L###"
  },
  {
    "prompt": "Find the last position of a substring in a string\n\n###\n\n",
    "completion": " a###"
  },
  {
    "prompt": "Limit input to certain number of times\n\n###\n\n",
    "completion": " L###"
  },
  {
    "prompt": "Limit input to specific count\n\n###\n\n",
    "completion": " i###"
  },
  {
    "prompt": "Limit input to a certain number of occurrences\n\n###\n\n",
    "completion": " L###"
  },
  {
    "prompt": "Limit input to a specific number of times\n\n###\n\n",
    "completion": " i###"
  },
  {
    "prompt": "A part that routes values to different outputs\n\n###\n\n",
    "completion": " S###"
  },
  {
    "prompt": "Switch between multiple output values\n\n###\n\n",
    "completion": " w###"
  },
  {
    "prompt": "A node that directs input values to different outputs\n\n###\n\n",
    "completion": " S###"
  },
  {
    "prompt": "A flow-based programming node that routes input values to different outputs\n\n###\n\n",
    "completion": " w###"
  },
  {
    "prompt": "Count items in list\n\n###\n\n",
    "completion": " L###"
  },
  {
    "prompt": "Get list length\n\n###\n\n",
    "completion": " i###"
  },
  {
    "prompt": "Calculate list size\n\n###\n\n",
    "completion": " L###"
  },
  {
    "prompt": "Determine number of items in list\n\n###\n\n",
    "completion": " i###"
  },
  {
    "prompt": "Loop through a list\n\n###\n\n",
    "completion": " L###"
  },
  {
    "prompt": "Iterate over a list\n\n###\n\n",
    "completion": " o###"
  },
  {
    "prompt": "Loop through items in a list\n\n###\n\n",
    "completion": " L###"
  },
  {
    "prompt": "Loop through a list and output item, index, and length\n\n###\n\n",
    "completion": " o###"
  },
  {
    "prompt": "Add item to beginning of list\n\n###\n\n",
    "completion": " P###"
  },
  {
    "prompt": "Prepend item to list\n\n###\n\n",
    "completion": " r###"
  },
  {
    "prompt": "Add to start of list\n\n###\n\n",
    "completion": " P###"
  },
  {
    "prompt": "Insert item at beginning of list\n\n###\n\n",
    "completion": " r###"
  },
  {
    "prompt": "Current Date\n\n###\n\n",
    "completion": " N###"
  },
  {
    "prompt": "Get Current Time\n\n###\n\n",
    "completion": " o###"
  },
  {
    "prompt": "Real-time Clock\n\n###\n\n",
    "completion": " N###"
  },
  {
    "prompt": "Part that outputs current date/time\n\n###\n\n",
    "completion": " o###"
  },
  {
    "prompt": "Convert date to year\n\n###\n\n",
    "completion": " D###"
  },
  {
    "prompt": "Extract year from date\n\n###\n\n",
    "completion": " a###"
  },
  {
    "prompt": "Get year from date\n\n###\n\n",
    "completion": " D###"
  },
  {
    "prompt": "Transform date to year\n\n###\n\n",
    "completion": " a###"
  },
  {
    "prompt": "Connect to database\n\n###\n\n",
    "completion": " C###"
  },
  {
    "prompt": "Establish database connection\n\n###\n\n",
    "completion": " o###"
  },
  {
    "prompt": "Create database connection\n\n###\n\n",
    "completion": " C###"
  },
  {
    "prompt": "Connect to database server\n\n###\n\n",
    "completion": " o###"
  },
  {
    "prompt": "Database connection initializer\n\n###\n\n",
    "completion": " F###"
  },
  {
    "prompt": "Initialize database connection\n\n###\n\n",
    "completion": " i###"
  },
  {
    "prompt": "Create database connection\n\n###\n\n",
    "completion": " F###"
  },
  {
    "prompt": "Connect to database\n\n###\n\n",
    "completion": " i###"
  },
  {
    "prompt": "Read contents of file\n\n###\n\n",
    "completion": " R###"
  },
  {
    "prompt": "Get file contents\n\n###\n\n",
    "completion": " e###"
  },
  {
    "prompt": "Read file data\n\n###\n\n",
    "completion": " R###"
  },
  {
    "prompt": "Retrieve file contents\n\n###\n\n",
    "completion": " e###"
  },
  {
    "prompt": "Connect to database\n\n###\n\n",
    "completion": " C###"
  },
  {
    "prompt": "Establish database connection\n\n###\n\n",
    "completion": " o###"
  },
  {
    "prompt": "Create database connection\n\n###\n\n",
    "completion": " C###"
  },
  {
    "prompt": "Connect to database server\n\n###\n\n",
    "completion": " o###"
  }
]